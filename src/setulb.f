c> \file setulb.f

c> \example driver1.f
c> This simple driver demonstrates how to call the L-BFGS-B code to
c> solve a sample problem (the extended Rosenbrock function
c> subject to bounds on the variables).
c> The dimension n of this problem is variable.
c> (Fortran-77 version)

c> \example driver1.f90
c> This simple driver demonstrates how to call the L-BFGS-B code to
c> solve a sample problem (the extended Rosenbrock function
c> subject to bounds on the variables).
c> The dimension n of this problem is variable.
c> (Fortran-90 version)

c> \example driver2.f
c> This driver shows how to replace the default stopping test
c> by other termination criteria. It also illustrates how to
c> print the values of several parameters during the course of
c> the iteration. The sample problem used here is the same as in
c> DRIVER1 (the extended Rosenbrock function with bounds on the variables).
c> (Fortran-77 version)

c> \example driver2.f90
c> This driver shows how to replace the default stopping test
c> by other termination criteria. It also illustrates how to
c> print the values of several parameters during the course of
c> the iteration. The sample problem used here is the same as in
c> DRIVER1 (the extended Rosenbrock function with bounds on the variables).
c> (Fortran-90 version)

c> \example driver3.f
c> This time-controlled driver shows that it is possible to terminate
c> a run by elapsed CPU time, and yet be able to print all desired
c> information. This driver also illustrates the use of two
c> stopping criteria that may be used in conjunction with a limit
c> on execution time. The sample problem used here is the same as in
c> driver1 and driver2 (the extended Rosenbrock function with bounds
c> on the variables).
c> (Fortran-77 version)

c> \example driver3.f90
c> This time-controlled driver shows that it is possible to terminate
c> a run by elapsed CPU time, and yet be able to print all desired
c> information. This driver also illustrates the use of two
c> stopping criteria that may be used in conjunction with a limit
c> on execution time. The sample problem used here is the same as in
c> driver1 and driver2 (the extended Rosenbrock function with bounds
c> on the variables).
c> (Fortran-90 version)

c> \brief This subroutine partitions the working arrays wa and iwa, and
c>        then uses the limited memory BFGS method to solve the bound
c>        constrained optimization problem by calling mainlb.
c>
c> This subroutine partitions the working arrays wa and iwa, and
c> then uses the limited memory BFGS method to solve the bound
c> constrained optimization problem by calling mainlb.
c> (The direct method will be used in the subspace minimization.)
c>
c> @param n On entry n is the dimension of the problem.<br/>
c>          On exit n is unchanged.
c>
c> @param m On entry m is the maximum number of variable metric corrections
c>             used to define the limited memory matrix.<br/>
c>          On exit m is unchanged.
c>
c> @param x On entry x is an approximation to the solution.<br/>
c>          On exit x is the current approximation.
c>
c> @param l On entry l is the lower bound on x.<br/>
c>          On exit l is unchanged.
c>
c> @param u On entry u is the upper bound on x.<br/>
c>          On exit u is unchanged.
c>
c> @param nbd On entry nbd represents the type of bounds imposed on the
c>               variables, and must be specified as follows:
c>               nbd(i)=<ul><li>0 if x(i) is unbounded,</li>
c>                          <li>1 if x(i) has only a lower bound,</li>
c>                          <li>2 if x(i) has both lower and upper bounds, and</li>
c>                          <li>3 if x(i) has only an upper bound.</li></ul>
c>            On exit nbd is unchanged.
c>
c> @param f On first entry f is unspecified.<br/>
c>          On final exit f is the value of the function at x.
c>
c> @param g On first entry g is unspecified.<br/>
c>          On final exit g is the value of the gradient at x.
c>
c> @param factr On entry factr >= 0 is specified by the user.  The iteration
c>                 will stop when<br/>
c>                 (f^k - f^{k+1})/max{|f^k|,|f^{k+1}|,1} <= factr*epsmch<br/>
c>                 where epsmch is the machine precision, which is automatically
c>                 generated by the code.<br/>
c>                 Typical values for factr:<ul>
c>                    <li>1.d+12 for low accuracy;</li>
c>                    <li>1.d+7  for moderate accuracy;</li>
c>                    <li>1.d+1 for extremely high accuracy.</li></ul>
c>              On exit factr is unchanged.
c>
c> @param pgtol On entry pgtol >= 0 is specified by the user.  The iteration
c>                 will stop when<br/>
c>                        max{|proj g_i | i = 1, ..., n} <= pgtol<br/>
c>                 where pg_i is the ith component of the projected gradient.<br/>
c>              On exit pgtol is unchanged.
c>
c> @param wa working array
c>
c> @param iwa working array
c>
c> @param task working string indicating
c>             the current job when entering and quitting this subroutine.
c>
c> @param iprint Must be set by the user.
c>               It controls the frequency and type of output generated:<ul>
c>               <li>iprint<0    no output is generated;</li>
c>               <li>iprint=0    print only one line at the last iteration;</li>
c>               <li>0<iprint<99 print also f and |proj g| every iprint iterations;</li>
c>               <li>iprint=99   print details of every iteration except n-vectors;</li>
c>               <li>iprint=100  print also the changes of active set and final x;</li>
c>               <li>iprint>100  print details of every iteration including x and g;</li></ul>
c>               When iprint > 0, the file iterate.dat will be created to
c>                                summarize the iteration.
c>
c> @param csave working string
c>
c> @param lsave working array;
c>              On exit with 'task' = NEW_X, the following information is
c>                                                                    available:<ul>
c>                <li>If lsave(1) = .true.  then  the initial X has been replaced by
c>                                                its projection in the feasible set;</li>
c>                <li>If lsave(2) = .true.  then  the problem is constrained;</li>
c>                <li>If lsave(3) = .true.  then  each variable has upper and lower
c>                                                bounds;</li></ul>
c>
c> @param isave working array;
c>              On exit with 'task' = NEW_X, the following information is
c>                                                                    available:<ul>
c>                <li>isave(22) = the total number of intervals explored in the
c>                                    search of Cauchy points;</li>
c>                <li>isave(26) = the total number of skipped BFGS updates before
c>                                    the current iteration;</li>
c>                <li>isave(30) = the number of current iteration;</li>
c>                <li>isave(31) = the total number of BFGS updates prior the current
c>                                    iteration;</li>
c>                <li>isave(33) = the number of intervals explored in the search of
c>                                    Cauchy point in the current iteration;</li>
c>                <li>isave(34) = the total number of function and gradient
c>                                    evaluations;</li>
c>                <li>isave(36) = the number of function value or gradient
c>                                              evaluations in the current iteration;</li>
c>                <li>if isave(37) = 0  then the subspace argmin is within the box;</li>
c>                <li>if isave(37) = 1  then the subspace argmin is beyond the box;</li>
c>                <li>isave(38) = the number of free variables in the current
c>                                    iteration;</li>
c>                <li>isave(39) = the number of active constraints in the current
c>                                    iteration;</li>
c>                <li>n + 1 - isave(40) = the number of variables leaving the set of
c>                                        active constraints in the current iteration;</li>
c>                <li>isave(41) = the number of variables entering the set of active
c>                                    constraints in the current iteration.</li></ul>
c>
c> @param dsave working array;
c>              On exit with 'task' = NEW_X, the following information is
c>                                                                    available:<ul>
c>                <li>dsave(1) = current 'theta' in the BFGS matrix;</li>
c>                <li>dsave(2) = f(x) in the previous iteration;</li>
c>                <li>dsave(3) = factr*epsmch;</li>
c>                <li>dsave(4) = 2-norm of the line search direction vector;</li>
c>                <li>dsave(5) = the machine precision epsmch generated by the code;</li>
c>                <li>dsave(7) = the accumulated time spent on searching for
c>                                                             Cauchy points;</li>
c>                <li>dsave(8) = the accumulated time spent on
c>                                                        subspace minimization;</li>
c>                <li>dsave(9) = the accumulated time spent on line search;</li>
c>                <li>dsave(11) = the slope of the line search function at
c>                                         the current point of line search;</li>
c>                <li>dsave(12) = the maximum relative step length imposed in
c>                                                                  line search;</li>
c>                <li>dsave(13) = the infinity norm of the projected gradient;</li>
c>                <li>dsave(14) = the relative step length in the line search;</li>
c>                <li>dsave(15) = the slope of the line search function at
c>                                        the starting point of the line search;</li>
c>                <li>dsave(16) = the square of the 2-norm of the line search
c>                                                             direction vector.</li></ul>
      subroutine setulb(n, m, x, l, u, nbd, f, g, factr, pgtol, wa, iwa,
     +                 task, iprint, csave, lsave, isave, dsave)

      character*60     task, csave
      logical          lsave(4)
      integer          n, m, iprint,
     +                 nbd(n), iwa(3*n), isave(44)
      double precision f, factr, pgtol, x(n), l(n), u(n), g(n),
c
c-jlm-jn
     +                 wa(2*m*n + 5*n + 11*m*m + 8*m), dsave(29)

c     ************
c
c     References:
c
c       [1] R. H. Byrd, P. Lu, J. Nocedal and C. Zhu, ``A limited
c       memory algorithm for bound constrained optimization'',
c       SIAM J. Scientific Computing 16 (1995), no. 5, pp. 1190--1208.
c
c       [2] C. Zhu, R.H. Byrd, P. Lu, J. Nocedal, ``L-BFGS-B: a
c       limited memory FORTRAN code for solving bound constrained
c       optimization problems'', Tech. Report, NAM-11, EECS Department,
c       Northwestern University, 1994.
c
c       (Postscript files of these papers are available via anonymous
c        ftp to eecs.nwu.edu in the directory pub/lbfgs/lbfgs_bcm.)
c
c                           *  *  *
c
c     NEOS, November 1994. (Latest revision June 1996.)
c     Optimization Technology Center.
c     Argonne National Laboratory and Northwestern University.
c     Written by
c                        Ciyou Zhu
c     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
c
c
c     ************
c-jlm-jn
      integer   lws,lr,lz,lt,ld,lxp,lwa,
     +          lwy,lsy,lss,lwt,lwn,lsnd

      if (task .eq. 'START') then
         isave(1)  = m*n
         isave(2)  = m**2
         isave(3)  = 4*m**2
         isave(4)  = 1                      ! ws      m*n
         isave(5)  = isave(4)  + isave(1)   ! wy      m*n
         isave(6)  = isave(5)  + isave(1)   ! wsy     m**2
         isave(7)  = isave(6)  + isave(2)   ! wss     m**2
         isave(8)  = isave(7)  + isave(2)   ! wt      m**2
         isave(9)  = isave(8)  + isave(2)   ! wn      4*m**2
         isave(10) = isave(9)  + isave(3)   ! wsnd    4*m**2
         isave(11) = isave(10) + isave(3)   ! wz      n
         isave(12) = isave(11) + n          ! wr      n
         isave(13) = isave(12) + n          ! wd      n
         isave(14) = isave(13) + n          ! wt      n
         isave(15) = isave(14) + n          ! wxp     n
         isave(16) = isave(15) + n          ! wa      8*m
      endif
      lws  = isave(4)
      lwy  = isave(5)
      lsy  = isave(6)
      lss  = isave(7)
      lwt  = isave(8)
      lwn  = isave(9)
      lsnd = isave(10)
      lz   = isave(11)
      lr   = isave(12)
      ld   = isave(13)
      lt   = isave(14)
      lxp  = isave(15)
      lwa  = isave(16)

      call mainlb(n,m,x,l,u,nbd,f,g,factr,pgtol,
     +  wa(lws),wa(lwy),wa(lsy),wa(lss), wa(lwt),
     +  wa(lwn),wa(lsnd),wa(lz),wa(lr),wa(ld),wa(lt),wa(lxp),
     +  wa(lwa),
     +  iwa(1),iwa(n+1),iwa(2*n+1),task,iprint,
     +  csave,lsave,isave(22),dsave)

      return

      end


